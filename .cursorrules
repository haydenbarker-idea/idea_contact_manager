# Contact Exchange App - Cursor Rules

## Project Context
You are building a professional contact exchange application called "Contact Exchange Pro" deployed at contacts.ideanetworks.com. This app enables seamless business card swapping via QR codes at conferences with automated multi-channel follow-ups.

## Tech Stack
- **Framework**: Next.js 14+ (App Router)
- **Language**: TypeScript (strict mode)
- **Styling**: Tailwind CSS + shadcn/ui
- **Database**: PostgreSQL
- **State**: React Context + Zustand for complex state
- **Authentication**: NextAuth.js
- **Deployment**: Docker container behind Nginx Proxy Manager

## Code Style & Standards

### TypeScript
- Use strict TypeScript with no implicit any
- Define interfaces for all data structures
- Use type guards for runtime validation
- Prefer interfaces over types for object shapes
- Use enums for fixed sets of values
- Always type function parameters and return values
- Use generics where appropriate for reusability

### File Structure
```
src/
‚îú‚îÄ‚îÄ app/                    # Next.js app router pages
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/            # Auth-protected routes
‚îÇ   ‚îú‚îÄ‚îÄ api/               # API routes
‚îÇ   ‚îî‚îÄ‚îÄ (public)/          # Public routes
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/                # shadcn/ui components
‚îÇ   ‚îú‚îÄ‚îÄ features/          # Feature-specific components
‚îÇ   ‚îî‚îÄ‚îÄ layout/            # Layout components
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ db/                # Database utilities
‚îÇ   ‚îú‚îÄ‚îÄ api/               # API helpers
‚îÇ   ‚îú‚îÄ‚îÄ utils/             # General utilities
‚îÇ   ‚îî‚îÄ‚îÄ validations/       # Zod schemas
‚îú‚îÄ‚îÄ types/                 # TypeScript type definitions
‚îú‚îÄ‚îÄ hooks/                 # Custom React hooks
‚îî‚îÄ‚îÄ store/                 # Zustand stores
```

### Naming Conventions
- **Files**: kebab-case (e.g., `contact-exchange.tsx`)
- **Components**: PascalCase (e.g., `ContactCard`)
- **Functions**: camelCase (e.g., `handleExchange`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_CONTACTS`)
- **Interfaces**: PascalCase with 'I' prefix optional (e.g., `Contact` or `IContact`)
- **Types**: PascalCase (e.g., `ExchangeMethod`)
- **Enums**: PascalCase with singular name (e.g., `ActionStatus`)

### React Components
- Use functional components with TypeScript
- Prefer named exports for components
- Use React.FC sparingly; explicit typing preferred
- Keep components under 200 lines; split if larger
- Extract business logic into custom hooks
- Use composition over prop drilling (Context when needed)

### Example Component Structure
```typescript
import { FC, useState, useCallback } from 'react';
import { Contact } from '@/types/contact';

interface ContactCardProps {
  contact: Contact;
  onExchange: (contactId: string) => Promise<void>;
  className?: string;
}

export function ContactCard({ contact, onExchange, className }: ContactCardProps) {
  const [isLoading, setIsLoading] = useState(false);

  const handleExchange = useCallback(async () => {
    setIsLoading(true);
    try {
      await onExchange(contact.id);
    } catch (error) {
      console.error('Exchange failed:', error);
    } finally {
      setIsLoading(false);
    }
  }, [contact.id, onExchange]);

  return (
    <div className={className}>
      {/* Component JSX */}
    </div>
  );
}
```

## API Development

### Route Structure
- Use Next.js API routes in `app/api/`
- Group related endpoints in folders
- Use proper HTTP methods (GET, POST, PUT, DELETE, PATCH)
- Return consistent JSON responses
- Include proper error handling

### Response Format
```typescript
// Success response
{
  success: true,
  data: { /* payload */ },
  message?: string
}

// Error response
{
  success: false,
  error: {
    code: 'ERROR_CODE',
    message: 'User-friendly message',
    details?: { /* additional info */ }
  }
}
```

### Error Handling
```typescript
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  try {
    // Route logic
    return NextResponse.json({ success: true, data: result });
  } catch (error) {
    console.error('API Error:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'EXCHANGE_FAILED',
          message: 'Failed to exchange contacts'
        }
      },
      { status: 500 }
    );
  }
}
```

## Database

### Prisma Schema Best Practices
- Use descriptive model names (PascalCase)
- Include createdAt and updatedAt timestamps
- Use appropriate field types (String, Int, DateTime, etc.)
- Define relationships explicitly
- Add indexes for frequently queried fields
- Use enums for fixed value sets

### Query Patterns
- Use Prisma Client for all database operations
- Prefer transactions for multi-step operations
- Use select to limit returned fields
- Implement pagination for list endpoints
- Use proper error handling with try-catch

### Example
```typescript
import { prisma } from '@/lib/db';

export async function exchangeContacts(userId: string, contactData: ContactInput) {
  return await prisma.$transaction(async (tx) => {
    const contact = await tx.contact.create({
      data: {
        userId,
        ...contactData,
      },
    });

    await tx.followUpAction.create({
      data: {
        contactId: contact.id,
        actionType: 'EMAIL',
        scheduledFor: new Date(Date.now() + 3600000), // 1 hour
        status: 'SCHEDULED',
      },
    });

    return contact;
  });
}
```

## State Management

### When to Use What
- **useState**: Simple local component state
- **useReducer**: Complex local state with multiple actions
- **Context**: Shared state across component tree (auth, theme)
- **Zustand**: Global state, complex state logic, persistence

### Zustand Store Pattern
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface ContactStore {
  contacts: Contact[];
  addContact: (contact: Contact) => void;
  removeContact: (id: string) => void;
  updateContact: (id: string, updates: Partial<Contact>) => void;
}

export const useContactStore = create<ContactStore>()(
  persist(
    (set) => ({
      contacts: [],
      addContact: (contact) => 
        set((state) => ({ contacts: [...state.contacts, contact] })),
      removeContact: (id) =>
        set((state) => ({ contacts: state.contacts.filter(c => c.id !== id) })),
      updateContact: (id, updates) =>
        set((state) => ({
          contacts: state.contacts.map(c => 
            c.id === id ? { ...c, ...updates } : c
          ),
        })),
    }),
    { name: 'contact-storage' }
  )
);
```

## Validation

### Use Zod for all validation
```typescript
import { z } from 'zod';

export const contactSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  email: z.string().email('Invalid email address'),
  phone: z.string().regex(/^\+?[1-9]\d{1,14}$/, 'Invalid phone number'),
  linkedin: z.string().url().optional(),
  company: z.string().max(100).optional(),
  title: z.string().max(100).optional(),
});

export type ContactInput = z.infer<typeof contactSchema>;
```

## UI/UX Guidelines

### Tailwind CSS
- Use Tailwind utility classes exclusively
- Follow mobile-first responsive design
- Use shadcn/ui components as base
- Maintain consistent spacing (4px grid)
- Use semantic color names from theme

### Animations
- Use Framer Motion for complex animations
- Keep animations under 300ms for UI feedback
- Use ease-out for entering elements
- Use ease-in for exiting elements
- Prefer transform and opacity for performance

### Accessibility
- Use semantic HTML elements
- Include ARIA labels where needed
- Ensure keyboard navigation works
- Maintain color contrast ratios (WCAG AA)
- Test with screen readers
- Include loading and error states

## Performance

### Optimization Strategies
- Use Next.js Image component for all images
- Implement dynamic imports for heavy components
- Use React.memo for expensive renders
- Debounce search and input handlers
- Implement virtual scrolling for long lists
- Use SWR or React Query for data fetching
- Enable Suspense boundaries for async components

### Bundle Size
- Monitor bundle size with @next/bundle-analyzer
- Lazy load non-critical components
- Tree-shake unused dependencies
- Minimize client-side JavaScript

## Security

### Critical Rules
- **Never** expose API keys in client-side code
- Validate all user inputs on server and client
- Sanitize all contact data before storage
- Use parameterized queries (Prisma handles this)
- Implement rate limiting on all API routes
- Use CSRF tokens for state-changing operations
- Validate file uploads strictly
- Implement proper session management
- Use HTTPS only (enforced by nginx)

### Input Sanitization
```typescript
import DOMPurify from 'isomorphic-dompurify';

export function sanitizeInput(input: string): string {
  return DOMPurify.sanitize(input, { ALLOWED_TAGS: [] });
}
```

## Testing

### Testing Strategy
- Write unit tests for utilities and hooks
- Write integration tests for API routes
- Write E2E tests for critical flows
- Use Jest + React Testing Library
- Use Playwright for E2E tests

### Test Structure
```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { ContactCard } from './contact-card';

describe('ContactCard', () => {
  it('should display contact information', () => {
    const contact = { name: 'John Doe', email: 'john@example.com' };
    render(<ContactCard contact={contact} onExchange={jest.fn()} />);
    
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });
});
```

## QR Code Handling

### Generation
- Use `qrcode.react` for basic QR codes
- Use `qr-code-styling` for branded/styled QR codes
- Include error correction level M (15%)
- Generate at 300x300px minimum
- Include vCard 3.0 format in QR data

### Scanning
- Use `react-qr-reader` or `html5-qrcode`
- Handle camera permissions gracefully
- Provide fallback for devices without camera
- Validate scanned data before processing
- Handle malformed QR codes gracefully

## vCard Format

### Standard Format
```typescript
export function generateVCard(contact: Contact): string {
  return `BEGIN:VCARD
VERSION:3.0
FN:${contact.name}
ORG:${contact.company || ''}
TITLE:${contact.title || ''}
TEL:${contact.phone}
EMAIL:${contact.email}
URL:${contact.linkedin || ''}
END:VCARD`;
}
```

## Logging & Monitoring

### Logging Strategy
- Use structured logging (JSON format)
- Log levels: error, warn, info, debug
- Include request IDs for tracing
- Log all API errors with context
- Use environment-based log levels

### Example
```typescript
import winston from 'winston';

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
  ],
});
```

## Environment Variables

### Required Variables
```bash
# See planning doc for full list
NEXT_PUBLIC_APP_URL=https://contacts.ideanetworks.com
DATABASE_URL=postgresql://...
NEXTAUTH_SECRET=...
SENDGRID_API_KEY=...
TWILIO_AUTH_TOKEN=...
```

### Usage
- Use `process.env.VAR_NAME` in server code
- Use `NEXT_PUBLIC_` prefix for client-exposed vars
- Validate required env vars at startup
- Use `.env.local` for local development
- Never commit `.env` files

## Git Workflow

### Commit Messages
Use conventional commits format:
- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation
- `style:` - Formatting, missing semicolons
- `refactor:` - Code restructuring
- `test:` - Adding tests
- `chore:` - Maintenance tasks

Example: `feat: add QR code scanning functionality`

### Branch Strategy
- `main` - Production-ready code
- `develop` - Integration branch
- `feature/*` - Feature branches
- `fix/*` - Bug fix branches

## Docker & Deployment

### Dockerfile Best Practices
- Use multi-stage builds
- Minimize layer count
- Use .dockerignore
- Don't run as root user
- Expose port 3000 (internal)

### Example Dockerfile
```dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
COPY --from=builder --chown=nextjs:nodejs /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json
USER nextjs
EXPOSE 3000
CMD ["npm", "start"]
```

## Automated Deployment & Troubleshooting Workflow

### Overview
This project uses an automated deployment loop that syncs logs to GitHub for remote troubleshooting. This enables seamless collaboration between the developer and AI assistant without requiring server access.

### The Workflow Loop

```
1. Developer runs deployment on server
   ‚Üì
2. Deployment script auto-syncs logs to GitHub (even on failure)
   ‚Üì
3. AI pulls logs locally: git pull origin <branch>
   ‚Üì
4. AI reads logs and identifies TypeScript/build errors
   ‚Üì
5. AI fixes errors and pushes to GitHub
   ‚Üì
6. Developer pulls and redeploys
   ‚Üì
7. Repeat until deployment succeeds
```

### Deployment Scripts

**Production:** `deploy-saas-instance.sh` - Full deployment with:
- Git configuration for automated log syncing
- EXIT trap (logs sync even on build failure)
- Visible console output (uses `tee`, not redirect)
- SSL certificate automation
- Communication tests (SMS/Email)
- GitHub log sync with visible confirmation

**Key Features:**
```bash
# Git configured immediately after initial setup
configure_git() {
    git config user.email "hbarker@ideanetworks.com"
    git config user.name "Hayden Barker"
}

# EXIT trap ensures logs sync regardless of outcome
trap 'handle_exit' EXIT

# All output visible AND logged
npm run build 2>&1 | tee -a "$LOG_FILE"
```

### AI Assistant Protocol

When user reports deployment results:

1. **Pull logs immediately:**
   ```bash
   git pull origin feature/viral-saas
   ```

2. **Check most recent log:**
   ```bash
   ls -lt deployment-logs/*.log
   # Read the newest saas-deploy-TIMESTAMP.log
   ```

3. **Identify errors automatically:**
   - TypeScript compilation errors
   - Missing type properties
   - Build failures
   - Runtime errors

4. **Fix and push:**
   - Fix identified TypeScript errors
   - Update type definitions
   - Commit with descriptive message
   - Push to GitHub immediately

5. **Provide single-line deploy command:**
   ```bash
   cd /var/www/contact-exchange-saas && git pull origin feature/viral-saas && sudo bash deploy-saas-instance.sh
   ```

### Log Analysis Patterns

**Look for these common issues:**

1. **TypeScript Errors:**
   ```
   Type error: Object literal may only specify known properties, 
   and 'fieldName' does not exist in type 'TypeName'
   ```
   **Fix:** Add missing field to interface in `src/types/index.ts`

2. **Build Failures:**
   ```
   Failed to compile.
   ./src/app/path/file.tsx:XX:X
   ```
   **Fix:** Read the specific file/line, fix type error

3. **Missing Dependencies:**
   ```
   Cannot find module 'package-name'
   ```
   **Fix:** Add to package.json and document

4. **Database Issues:**
   ```
   table "table_name" does not exist
   ```
   **Fix:** Check schema.prisma, run migrations

### Log Location & Format

**Server Path:** `/var/www/contact-exchange-saas/deployment-logs/`
**Local Path:** `deployment-logs/`
**Naming:** `saas-deploy-YYYYMMDD_HHMMSS.log`

**Log Contents:**
- All deployment steps with timestamps
- Full npm build output
- Database migration results
- Service start/stop status
- SSL certificate generation
- Communication test results
- Git sync confirmation

### Success Indicators

Deployment succeeded when log shows:
```
‚úì Build completed successfully
‚úì Service started successfully
‚úì Logs synced to GitHub successfully
=== DEPLOYMENT SUCCESS ===
```

### Failure Indicators

Deployment failed when log shows:
```
‚úó Build failed - server.js not found
‚úó Service failed to start
‚úó === DEPLOYMENT FAILED ===
Failed at step: STEP X: Description
```

### TypeScript Type Fixes

**Common additions to `src/types/index.ts`:**

```typescript
export interface ApiResponse<T = any> {
  success: boolean
  data?: T
  message?: string       // Success messages
  available?: boolean    // Slug/resource availability checks
  error?: {
    code: string
    message: string
  }
}

export interface UserProfile {
  // ... existing fields
  photoUrl?: string      // User headshots
  bio?: string          // User bios
}
```

### Communication with User

**When user says "I deployed" or "deployment completed":**
1. Immediately pull logs without asking
2. Read the latest log file
3. If errors: Fix them and push
4. If success: Congratulate and provide next steps
5. Always provide the single-line deploy command

**Never:**
- Ask "can you paste the output?" (logs are in GitHub)
- Wait for user to tell you what failed (read logs yourself)
- Make multiple commits for related type errors (batch fixes)
- Hide your troubleshooting process (be transparent)

### Example Session

```
User: "I ran the deployment"

AI: *Pulls logs, reads latest file, sees TypeScript error*
    "I found a TypeScript error - the UserProfile type is missing 
    the photoUrl field. Fixing now..."
    *Fixes type, commits, pushes*
    "Fixed! Run this to deploy:"
    cd /var/www/contact-exchange-saas && git pull origin feature/viral-saas && sudo bash deploy-saas-instance.sh
```

### Benefits of This Workflow

1. **No copy/paste needed** - Logs auto-sync to GitHub
2. **AI sees full context** - Complete build output and errors
3. **Fast iteration** - Fix ‚Üí push ‚Üí deploy loop in minutes
4. **Persistent history** - All deployment logs saved in repo
5. **Works remotely** - No server access needed for AI
6. **Self-healing** - Logs sync even on catastrophic failure

### Integration with Git Workflow

- Logs committed with message: `logs: deployment TIMESTAMP - status`
- Never conflicts with code changes (separate directory)
- Ignored in .gitignore for local dev (server commits them)
- Part of feature branch, merged to main when stable

---

## Quick Deploy & Management

### Quick Deploy Script

Use `quick-deploy-saas.sh` for fast iterations:

```bash
cd /var/www/contact-exchange-saas && git pull origin feature/viral-saas && sudo bash quick-deploy-saas.sh
```

**What it does:**
1. Pulls latest code from GitHub
2. Installs/updates dependencies
3. Regenerates Prisma client
4. Builds Next.js app (~90 seconds)
5. Copies static files to standalone build
6. Restarts systemd service
7. Tests SMS/Email communications (with auth)
8. Verifies HTTPS connection
9. Shows database stats
10. **Automatically syncs logs to GitHub**

**Key Features:**
- EXIT trap syncs logs even on failure
- Authenticates test endpoints with ADMIN_PASSWORD
- Extracts and displays success/error messages
- Distinguishes "not configured" from "failed"
- Real-time visible output + log file

### Database Management

**Interactive admin tool:**
```bash
cd /var/www/contact-exchange-saas && sudo bash db-admin.sh
```

**Menu options:**
1. View stats (user & contact counts)
2. Clean database (requires typing "DELETE")
3. List all users
4. List all contacts
5. View recent activity

**Quick commands:**
```bash
# Check counts (use sudo -u postgres)
sudo -u postgres psql -d contact_exchange_saas -c 'SELECT COUNT(*) FROM users; SELECT COUNT(*) FROM contacts;'

# Clean database
sudo -u postgres psql -d contact_exchange_saas -c 'DELETE FROM contacts; DELETE FROM users;'
```

**Note:** PostgreSQL commands MUST use `sudo -u postgres` prefix (root user doesn't exist in PostgreSQL).

### SSL Configuration & Troubleshooting

**Common SSL issues:**

1. **HTTP but not HTTPS**
   - Symptom: Site loads but shows "Not secure"
   - Cause: Nginx not configured to redirect HTTP ‚Üí HTTPS
   - Fix: `sudo bash fix-saas-ssl.sh`

2. **Mixed content warnings**
   - Symptom: HTTPS loads but browser warns about insecurity
   - Cause: Resources loaded over HTTP
   - Fix: Ensure all URLs use HTTPS or relative paths

3. **Certificate exists but not used**
   - Symptom: `certbot certificates` shows cert, but site uses HTTP
   - Cause: Nginx config only listens on port 80
   - Fix: Proper Nginx config with ports 80 (redirect) and 443 (SSL)

**SSL fix script creates:**
- HTTP server block (port 80) ‚Üí redirects to HTTPS
- HTTPS server block (port 443) ‚Üí serves app securely
- Security headers (HSTS, X-Frame-Options, etc.)
- Proper proxy headers for Next.js

### Communication Testing

**Test endpoints require authentication:**
- SMS: `POST /api/test/sms` (requires `Authorization: Basic` header)
- Email: `POST /api/test/email` (requires `Authorization: Basic` header)

**Quick deploy script:**
- Reads ADMIN_PASSWORD from .env
- Creates Base64 auth header automatically
- Tests both SMS and Email
- Reports success/failure/not-configured

**Admin notifications:**
- Sends SMS to admin (+16476242735) on new user signup
- Sends SMS to admin on new contact connection
- Shows who signed up and who connected with whom
- Non-blocking (won't slow down users)

### Mobile-Specific Fixes

**Photo upload on Android:**
- **Problem:** Single file input doesn't give camera option
- **Solution:** Separate "Take Photo" and "Upload Photo" buttons
- **Implementation:**
  ```html
  <input id="photo-camera" type="file" accept="image/*" capture="environment" />
  <input id="photo-upload" type="file" accept="image/*" />
  ```
- **Used in:** `/get-started` (Step 2) and `/settings`

**Responsive buttons:**
- Show icon-only on mobile (save space)
- Show icon + text on desktop/tablet
- Use Tailwind breakpoints: `hidden md:inline`

### Common Deployment Issues

**1. TypeScript errors with missing exports**
```
Module '"@/lib/auth"' has no exported member 'getUserFromSession'
```
**Fix:** Check available exports, use correct function name (e.g., `getSession` not `getUserFromSession`)

**2. Admin page loading issues**
```
Loading state starts as `true`, prevents login form
```
**Fix:** Set initial `loading` state to `false` for pages that should show immediately

**3. Settings page not accessible**
```
Middleware doesn't protect /settings route
```
**Fix:** Add `/settings` to `protectedRoutes` and middleware `matcher`

**4. Environment variable parsing errors**
```
.env: line 13: Barker: command not found
```
**Fix:** Use `set -a; source .env; set +a` instead of `export $(cat .env | xargs)`

**5. Static files not copying**
```
cp: cannot create directory '.next/standalone/.next/static'
```
**Cause:** Build failed, .next/standalone doesn't exist
**Fix:** Check TypeScript errors, rebuild successfully

### Profile Editing Feature

**Pages:**
- `/settings` - Full profile editor (requires auth)
- Settings button in dashboard (responsive)

**Features:**
- Edit all profile fields (name, email, phone, company, title, bio)
- Upload new photo (camera or gallery)
- Change password (requires current password)
- Email uniqueness validation
- Password strength validation (min 6 chars)

**API:**
- `GET /api/users/me` - Get current user profile
- `PATCH /api/users/me` - Update profile
- Uses `getSession()` from `@/lib/auth`

### Middleware Protection

**Protected routes:**
```typescript
const protectedRoutes = ['/dashboard', '/settings']
```

**Matcher:**
```typescript
matcher: ['/dashboard/:path*', '/settings/:path*', '/login']
```

**Redirects:**
- Protected route + no session ‚Üí `/login?redirect=<path>`
- Login + has session ‚Üí `/dashboard`

### Admin Notifications

**Notifications sent to:** `NEXT_PUBLIC_DEFAULT_USER_PHONE` (from .env)

**New user signup:**
```
üéâ NEW USER SIGNUP!
Name: John Smith
Email: john@company.com
Phone: +15551234567
Company: ACME Inc
Profile: https://saas.../u/john-smith
```

**New contact connection:**
```
ü§ù NEW CONNECTION!
Jane Doe connected with John Smith
Contact Info: [details]
Collected by: John Smith
Profile: https://saas.../u/john-smith
```

**Implementation:**
- `src/lib/admin-notifications.ts` - notification functions
- Integrated into `/api/users/signup` and `/api/contacts/submit`
- Non-blocking (uses `.catch()` for errors)
- Only sends if Twilio configured

### Deployment Checklist

Before deploying to production:

1. **Environment:**
   - [ ] All .env variables set correctly
   - [ ] ADMIN_PASSWORD configured
   - [ ] Twilio credentials set (for SMS)
   - [ ] Resend API key set (for email)
   - [ ] Phone number in correct format (+16476242735)

2. **Database:**
   - [ ] Clean database (0 users, 0 contacts)
   - [ ] Schema up to date (`npx prisma db push`)
   - [ ] Prisma client generated

3. **SSL:**
   - [ ] Certificate obtained for domain
   - [ ] HTTP redirects to HTTPS
   - [ ] Security headers configured
   - [ ] No mixed content warnings

4. **Testing:**
   - [ ] SMS test successful
   - [ ] Email test successful
   - [ ] Admin notifications working
   - [ ] Photo upload works on mobile
   - [ ] Settings page accessible
   - [ ] Login/logout functional

5. **Verification:**
   - [ ] Visit `https://saas.contacts.ideanetworks.com`
   - [ ] Shows secure padlock
   - [ ] Admin page loads (`/admin`)
   - [ ] Dashboard loads (`/dashboard`)
   - [ ] Settings loads (`/settings`)

### Troubleshooting Commands

**Service management:**
```bash
sudo systemctl status contact-exchange-saas
sudo systemctl restart contact-exchange-saas
journalctl -u contact-exchange-saas -f
```

**Database queries:**
```bash
sudo -u postgres psql -d contact_exchange_saas
# Inside psql:
SELECT COUNT(*) FROM users;
SELECT * FROM users ORDER BY created_at DESC LIMIT 5;
\dt  # List tables
\q   # Quit
```

**Nginx:**
```bash
sudo nginx -t  # Test config
sudo systemctl reload nginx
sudo systemctl status nginx
```

**SSL certificates:**
```bash
sudo certbot certificates
sudo certbot renew --dry-run
```

**Logs:**
```bash
# View latest deployment log
ls -lt deployment-logs/*.log | head -1
tail -100 deployment-logs/<latest>.log
```

---

## Code Review Checklist

Before committing, ensure:
- [ ] TypeScript compiles with no errors
- [ ] ESLint passes with no warnings
- [ ] Code is formatted with Prettier
- [ ] All tests pass
- [ ] No console.logs in production code
- [ ] Error handling is comprehensive
- [ ] Inputs are validated and sanitized
- [ ] Comments explain "why" not "what"
- [ ] No hardcoded values (use constants/env vars)
- [ ] Responsive design tested on mobile
- [ ] Accessibility requirements met

## Common Patterns

### Data Fetching with SWR
```typescript
import useSWR from 'swr';

export function useContacts() {
  const { data, error, mutate } = useSWR<Contact[]>('/api/contacts');
  
  return {
    contacts: data,
    isLoading: !error && !data,
    isError: error,
    mutate,
  };
}
```

### Form Handling
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

export function ContactForm() {
  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: zodResolver(contactSchema),
  });

  const onSubmit = async (data: ContactInput) => {
    // Handle form submission
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Form fields */}
    </form>
  );
}
```

## Key Principles

1. **Type Safety First**: Leverage TypeScript's type system fully
2. **Progressive Enhancement**: App should work without JavaScript for basic features
3. **Mobile First**: Design for mobile, enhance for desktop
4. **Accessibility**: Build for everyone
5. **Performance**: Fast load times, smooth interactions
6. **Security**: Validate everything, trust nothing
7. **Maintainability**: Write code others can understand
8. **User Experience**: Smooth, intuitive, delightful
9. **Error Recovery**: Graceful failure, helpful messages
10. **Documentation**: Code should be self-documenting, but comment complex logic

## Resources

- [Next.js Docs](https://nextjs.org/docs)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Tailwind CSS](https://tailwindcss.com/docs)
- [shadcn/ui](https://ui.shadcn.com/)
- [Prisma Docs](https://www.prisma.io/docs)
- [vCard RFC](https://datatracker.ietf.org/doc/html/rfc6350)

---

**When in doubt**: Prioritize type safety, user experience, and security. Ask for clarification rather than making assumptions.